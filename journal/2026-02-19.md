# 2026-02-18 - Bash

## Cel

- `docs/bash.md`
- Shebang
- `[[ ... ]]` vs. `[ ... ]`
- `[[ ... ]] && command` vs. `if [[ ... ]]; then; command ...`
- `"$HOME"` vs. `'$HOME'` vs. `\`$HOME\``
- `labs/01-shell/README.md`

## Komendy

```bash
Komentarze
Zaczynają się od #.

Przykład:
# This script prints a greeting message
echo "Hello, World!"

Średniki
Pozwalają wykonywać wiele poleceń w jednej linii.

Przykład:
echo "This is a test"; echo "This is another test"




Bash Script
Pliki zawierające polecenia do wykonania w terminalu. 

Tworzenie skryptu 
#!/bin/bash
• #! - shebang, mówi systemowi, że plik jest skryptem i należy go wykonać za pomocą podanego interpretera
• /bin/bash - ścieżka do Bash

Przykład:
#!/bin/bash
# This script prints a greeting message
echo "Hello, World!"




Zmienne
Służą do przechowywania danych, nie trzeba określać typu zmiennej.

Deklarowanie zmiennych
Aby użyć wartości zmiennej, dodaj $ przed nazwą.

Przykład:
name="John Doe"
echo "Hello, $name!"
number=42
echo "The number is $number"

Zmienne środowiskowe
Specjalne zmienne wpływające na działanie procesów w systemie, przechowują, np. ścieżki do programów.

Przykład:
# Display the PATH environment variable
echo "Your PATH is $PATH"

Zmienne lokalne i globalne
• lokalne - dostępne tylko w bloku kodu
• globalne - dostępne w całym skrypcie

Przykład:
# Define a local variable in a function
my_function() {
  local local_var="I am local"
  echo $local_var
}
my_function

Operacje na zmiennych
• konkatenacja - łączenie tekstów
Przykład:
greeting="Hello, "
name="World"
echo "$greeting$name"

• arytmetyka - obliczenia
Przykład:
num1=5
num2=10
sum=$((num1 + num2))
echo "The sum is $sum"




Typy danych

String
Przechowują tekst, można je łączyć (konkatenacja) lub wyciągać fragmenty (substring).

Przykład:
# String example
greeting="Hello, World!"
name="Alice"
full_greeting="$greeting, $name!"
echo $full_greeting

Number
Używane do operacji arytmetycznych.

Przykład:
# Number example
num1=5
num2=10
sum=$((num1 + num2))
difference=$((num2 - num1))
product=$((num1 * num2))
quotient=$((num2 / num1))
echo "Sum: $sum, Difference: $difference, Product: $product, Quotient: $quotient"

Array
Przechowują wiele wartości w jednej zmiennej, każdy element ma indeks, można iterować po elementach i je modyfikować.

Przykład:
# Array example
fruits=("apple" "banana" "cherry")
for fruit in "${fruits[@]}"; do
  echo $fruit
done


Associative Arrays (tablice asocjacyjne)
Używają nazwanych kluczy zamiast numerów indeksów.

Przykład:
# Associative array example
declare -A colors
colors[apple]="red"
colors[banana]="yellow"
colors[grape]="purple"
unset colors[banana]
echo ${colors[apple]} # red
echo ${colors[grape]} # purple

Bash nie obsługuje liczb zmiennoprzecinkowych natywnie.



Operatory

Operatory porównania liczb
• -eq : równe (==)
• -ne : nierówne (!=)
• -lt : mniejsze niż (<)
• -le : mniejsze lub równe (<=)
• -gt : większe niż (>)
• -ge : większe lub równe (>=)

Operatory porównania tekstu
• = : równe
• != : nierówne
• < : mniejsze w kolejności ASCII
• > : większe w kolejności ASCII

Operatory arytmetyczne
• + : dodawanie
• - : odejmowanie
• * : mnożenie
• / : dzielenie
• % : modulo (reszta z dzielenia)

Operatory logiczne
• && : AND
• || : OR
• ! : NOT

Operatory testowania plików
• -e : sprawdza, czy plik istnieje
• -d : sprawdza, czy istnieje katalog
• -f : sprawdza, czy plik jest zwykłym plikiem
• -s : sprawdza, czy plik nie jest pusty




Instrukcje

If...
Wykonuje blok kodu, jeśli warunek jest prawdziwy, warunki zapisuje się w [], blok kończy się słowem fi.

Przykład:
# Basic if statement
num=15
if [ $num -gt 10 ]; then
  echo "Number is greater than 10"
fi

If...Else
Pozwala wykonać alternatywny blok kodu, jeśli jest fałszywy, else wprowadza blok alternatywny.

Przykład:
# If...else statement
num=8
if [ $num -gt 10 ]; then
  echo "Number is greater than 10"
else
  echo "Number is 10 or less"
fi

Elif
Umożliwia sprawdzenie wielu warunków po kolei.

Przykład:
# If...elif...else statement
num=10
if [ $num -gt 10 ]; then
  echo "Number is greater than 10"
elif [ $num -eq 10 ]; then
  echo "Number is exactly 10"
else
  echo "Number is less than 10"
fi

Zagnieżdżone if
Pozwalają umieścić jedno if wewnątrz innego, każdy blok if kończy się swoim własnym fi.

Przykład:
# Nested if statement
num=5
if [ $num -gt 0 ]; then
  if [ $num -lt 10 ]; then
    echo "Number is between 1 and 9"
  fi
fi




Pętle

For
Służą do iteracji po liście elementów lub zakresie liczb.

Przykład:
# For loop example
for i in {1..5}; do
  echo "Iteration $i"
done

While
Wykonuje blok kodu dopóki warunek jest prawdziwy.

Przykład:
# While loop example
count=1
while [ $count -le 5 ]; do
  echo "Count is $count"
  ((count++))
done

Until
Wykonuje blok kodu dopóki warunek jest fałszywy.

Przykład
# Until loop example
count=1
until [ $count -gt 5 ]; do
  echo "Count is $count"
  ((count++))
done

Break i continue
• break - wychodzi z pętli całkowicie
• continue - pomija bieżącą iterację i przechodzi do następnej

Przykład:
# Break and continue example
for i in {1..5}; do
  if [ $i -eq 3 ]; then
    continue
  fi
  echo "Number $i"
  if [ $i -eq 4 ]; then
    break
  fi
done

Pętle zagnieżdżone
Jedna pętla w środku drugiej, każda pętla kończy się swoim done
# Nested loops example
for i in {1..3}; do
  for j in {1..2}; do
    echo "Outer loop $i, Inner loop $j"
  done
done




Funkcje

Definiowanie funkcji
Funkcje definiuje się za pomocą nazwy, nawiasów () i bloku [].

Przykład:
my_function() {
  echo "Hello, World!"
}

Wywoływanie funkcji
Funkcje wywołuje się poprzez jej nazwę.

Przykład:
my_function

Funkcje z argumentami
unkcje mogą przyjmować argumenty, które są dostępne jako $1, $2,...

Przykład:
greet() {
  local name=$1
  echo "Hello, $name!"
}
greet "Alice"

Zwracanie wartości z funkcji
Wartości zwraca się za pomocą echo lub return, wynik echo można przepisać do zmiennej przy wywołaniu funkcji.

Przykład:
add() {
  local sum=$(($1 + $2))
  echo $sum
}
result=$(add 5 3)
echo "The sum is $result"




Tablice
Tablice pozwalają przechowywać wiele wartości w jednej zmiennej.

Tworzenie tablic

Przykład:
my_array=("value1" "value2" "value3")

Dostęp do elementów tablicy

Przykład:
echo ${my_array[0]}

Modyfikowanie elementów tablicy

Przykład:
my_array[1]="new_value"

############################

[ ... ]
# - Jest zgodne z POSIX
# - Jest zwykłą komendą (wbudowaną w Bash, ale nadal komendą)
# - ] to po prostu ostatni argument polecenia [
# - Bash parsuje ją jak każdą inną komendę

[[ ... ]]
# - Jest rozszerzeniem Bash
# - Jest słowem kluczowym (keyword), nie zwykłą komendą
# - Całość jest specjalną konstrukcją składniową
# - Bash parsuje jej zawartość „magicznie” (inaczej niż zwykłe polecenie)

Najważniejsza różnica:
[ - działa jak normalne polecenie
[[ - jest elementem składni języka Bash

------------------------------

"$HOME" -> Odnosi się do zawartości zmiennej "HOME"
'$HOME' -> Jest stringiem o treści '$HOME'
\$HOME -> Jest prawie tym samym co poprzedni wypadek, jednak tutaj przez znak \ odbierane jest działanie znaku $ jako wskaźnika

------------------------------

if [[ ... ]]; then ... fi
Pełna instrukcja warunkowa, bardziej czytelna przy większej ilości kodu.

[[ ... ]] && polecenie
Wykonuje polecenie tylko wtedy, gdy warunek jest prawdziwy.

Przykłady:
x="yes"

[[ $x == "yes" ]] && echo "Zatwierdzono"

if [[ $x == "yes" ]]; then
echo "Zatwierdzono"
fi

```
